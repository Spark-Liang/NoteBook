##### SQL server 排序规则

- 查看排序规则相关信息

- 排序规则分类

- 排序规则优先级

- 性能相关问题

- 具体编码排序问题



###### 查看排序规则相关信息

- 使用 **DATABASEPROPERTYEX('database_name','collation')** 查看当前DB 排序规则

- 表和列的排序规则信息可以通过对应的目录视图查看。

- 通过目录函数 sys.fn_helpcollations() 查看可用可用规则

###### 排序规则分类

排序规则的命名规则如下：

```textile
<SQL_collation_name> :: = 
     SQL_SortRules[_Pref]_CPCodepage_<ComparisonStyle>

<ComparisonStyle> ::=
        _CaseSensitivity_AccentSensitivity | _BIN
```

***SortRules***

**标识字母表或语言的字符串，当指定按字典排序时应用该字母表或语言的排序规则**。例如 Latin1_General 或波兰语，简体中文为Chinese_PRC，繁体中文为Chinese_Taiwan。

**Pref**

指定大写字母优先。

**Codepage**

指定用于标识排序规则所使用的代码页的 1 至 4 位数号码。CP1 指定代码页 1252，对于所有其他代码页，则需要指定完整的代码页号码。例如，CP1251 指定代码页 1251，CP850 指定代码页 850。

*CaseSensitivity* _CI(CS)

**CI 指定不区分大小写，CS 指定区分大小写。**

如果想让比较将大写字母和小写字母视为不等，请选择该选项。

区分大写字母和小写字母。如果选择此项，排序时小写字母将在其对应的大写字母之前。

如果未选择此选项，则 SQL Server 认为字母的大小写形式对于排序目的而言是相同的。

***AccentSensitivity*  _AI(AS)**

AI 指定不区分重音，AS 指定区分重音。

如果想让比较将重音和非重音字母视为不等，请选择该选项。如果选择该选项， 比较还将重音不同的字母视为不等。

区分重音字符和非重音字符。例如，“a”和“?”将被视为不同的字符。

如果未选择此项，在排序时，SQL Server 将把字母的重音形式和非重音形式视为相同。

_KI(KS)

是否区分假名类型,KI不区分，KS区分。

区分日语里面的两种假名字符类型：平假名，片假名。

_WI(WS)

是否区分宽度 WI不区分，WS区分。

区分字符的单字符宽度形式和双字符宽度形式。

如果未选择此项，在排序时，SQL Server 将把同一字符的单字节形式和双字节形式视为相同。  


**BIN**

指定使用二进制排序顺序。

二进制排序规则基于区域设置和数据类型所定义的编码值的顺序，对数据进行排序。SQL Server 中的二进制排序规则强制使用二进制排序顺序，定义了要使用的语言区域设置和 ANSI 代码页。由于二进制排序规则相对简单，因此对改进应用程序的性能非常有用。对于非 Unicode 数据类型，数据比较将基于 ANSI 代码页中定义的码位。对于 Unicode 数据类型，数据比较将基于 Unicode 码位。对于 Unicode 数据类型的二进制排序规则，数据排序将不考虑区域设置。例如，对 Unicode 数据应用 Latin_1_General_BIN 和 Japanese_BIN，会得到完全相同的排序结果。

###### SQL Server 中的早期二进制排序规则对 Unicode 数据执行的是不完整的逐码位比较。更早的 SQL Server 二进制排序规则将第一个字符作为 WCHAR 比较，接下来是逐字节比较。为了实现向后兼容，将不更改现有的二进制排序规则语义。



###### 排序规则优先级

| 排序规则应用类型（优先级以此提高，无排序规则除外） | 对象类型                                                                                                                          |
| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| 强制默认                      | 任何 Transact-SQL 字符串变量、参数、文字、目录内置函数的输出或不使用字符串输入但生成字符串输出的内置函数。<br/>在自定义函数，存储过程，触发器中默认采用DB 默认排序规则。<br/>在script中声明的对象采用当前连接默认排序规则 |
| 隐式X                       | 列引用。 从为表或视图中的列定义的排序规则得到表达式 (X) 的排序规则。                                                                                         |
| 显式X                       | 使用表达式中的 COLLATE 子句显式转换为特定排序规则 (X) 的表达式。                                                                                       |
| 无排序规则                     | 指示表达式的值是两个字符串之间的运算结果，而这两个字符串具有隐式排序规则标签的冲突排序规则。 表达式的结果被定义为不具有排序规则（**即无法进行与顺序有关操作比如找最大值**）。                                     |

- 显式优先于隐式。  隐式优先于强制默认：
  
  显式 > 隐式 > 强制默认

- 组合两个已被分配有不同排序规则的显式表达式将生成错误：
  
  显式 X + 显式 Y = 错误

- 组合两个具有不同排序规则的隐式表达式将生成无排序规则的结果：
  
  隐式 X + 隐式 Y = 无排序规则

- 将无排序规则的表达式与除显式排序规则（参阅下一个规则）之外任何标签表达式组合都将生成无排序规则标签的结果：
  
  无排序规则 + 任何内容 = 无排序规则

- 将无排序规则的表达式与具有显式排序规则的表达式组合将生成具有显式标签的表达式：
  
  无排序规则 + 显式 X = 显式



###### 性能相关问题

通常使用 BIN 后缀的排序规则性能更高。



###### 具体编码排序问题

sql server 对字符串排序和通常的字符串排序基本相同，都是从第一个字节开始比较。对于前缀相同，长度不同两个字符串，长度短的比长度长的小。

**但是sql server 中，对控制字符（ascii 0 到 31）的排序行为，不同的排序规则会有所不同**

有些排序规会有如下行为

```sql

select iif('a' > 'a'+char(0) collate Latin1_General_100_BIN ,1,0)  
--1

select iif('a' = 'a'+char(0) collate Latin1_General_100_CS_AS_KS_WS,1,0)
 --1
```
